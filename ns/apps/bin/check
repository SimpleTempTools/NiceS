#!/home/s/ops/perl/bin/perl
use strict;
use warnings;
use NS::Util::OptConf;
use Sys::Hostname;
use YAML::XS;
use Data::Dumper;
use Encode;
use LWP::UserAgent;
use IO::Socket;

use Net::DNS::Dig;
use NetAddr::IP::Util qw(inet_ntoa);
use FindBin qw( $RealBin );

$| ++;

my ( $option, %apps );
BEGIN { %apps = NS::Util::OptConf->load()->dump('apps'); }

my %o = NS::Util::OptConf->load()->get( qw( range=s apps=s check=s verbose ) )->dump();

my $arg; map{ $arg .= $o{$_} ? " --$_ $o{$_} " : '' } qw( check );

our $verbose = $o{verbose};

my $ver = $o{verbose} ? " --verbose  ":'';
exec "$RealBin/../../tools/mcmd -r '$o{range}' \"$0 $ver $arg {}\"" if $o{range};
print "\n";
my ( $check, @a ) = $ARGV[0] || hostname;

my $node = eval { YAML::XS::LoadFile( "$apps{data}/node" ) } || die 'cannot find the node file';

#my @hermes = $o{apps} ? split ',', $o{apps} : keys $node->{$check} if $node->{$check};
my @hermes;
if ( $node->{$check} )
{
    #@hermes = $o{apps} ? split ',', $o{apps} : keys $node->{$check};
    @hermes = $o{apps} ? $o{apps} : keys $node->{$check};
}
else {print "$check: not in standard hermes!\n"}

my $config = eval { YAML::XS::LoadFile( "$apps{conf}/check" ) } || die 'cannot find the config file';
my $count = 0;
map
{
    my $conf =$config->{$_};
    if ( $conf )
    {
        for my $c ( ref $conf eq 'ARRAY' ? @$conf : ( $conf ) )
        {
            die "invalid conf: no HASH" if ref $c ne 'HASH';
            my @check;
            push @check, $check;
            map{ apps_http( $_, %$c ) }@check if $c->{http};
            map{ apps_port( $_, %$c ) }@check if $c->{port};
            map{ apps_port( $_, %$c ) }@check if $c->{tcp};
            map{ apps_port( $_, %$c ) }@check if $c->{udp};
            map{ apps_code( $_, %$c ) }@check if $c->{code};
            map{ apps_dns(  $_, %$c ) }@check if $c->{domain};
            map{ apps_domain(  $_, %$c ) }@check if $c->{dns};
        }
     $count++;
    }
}@hermes; 

unless ( $count )
{
   print "$check: undef app in the config file!\n";
}

sub apps_dns
{
    my ( $host, %conf ) = @_;

    my @to = _dig( $conf{domain} , $host, $conf{timeout}  );
    printf "to: %s\n", join ',', @to if $verbose;

    @to ? print "$host <> to $conf{domain} :OK\n" : die "$host <> to $conf{domain} :FAIL\n"; 
}

sub apps_domain
{
    my ( $host, %conf ) = @_;

    my @to = _dig( $host, $conf{dns} , $conf{timeout}  );
    printf "to: %s\n", join ',', @to if $verbose;

    @to ? print "$host <> from $conf{dns} :OK\n" : die "$host <> from $conf{dns} :FAIL\n"; 
}

sub apps_code
{
    my ( $host, %conf ) = @_;
    my $code = $conf{code};
    die "$host <> $code :FAIL [no code]\n" unless -x $code;
    system( "$code $host" ) ? die "$host <> $code :FAIL\n" : print "$host <> $code :OK\n"; 
}

sub apps_port
{
    my ( $host, %conf ) = @_;
    my ( $port, $t );
    map{ if( $conf{$_} ){ $t = $_; $port = $conf{$_}; } }qw( tcp udp port );
    my $info = sprintf "$host <>$t $port";

    ioso( "$host:$port", $t eq 'port' ? '' : $t )
      ? print "$info :OK\n" : die "$info :FAIL\n";
}

sub apps_http
{
    my ( $host, %conf ) = @_;
    $conf{http} =~ s/{}/$host/g;
    Encode::_utf8_off( $conf{check} ) if defined $conf{check};
    my $info = $conf{check} || '';
    check_http_conten( %conf )
      ? print "$conf{http} <> $info :OK\n" : die "$conf{http} <> $info :FAIL\n";
}

sub check_http_conten
{
    my %conf = @_;
    my $content = $conf{Data} ? `curl $conf{http} -d '$conf{Data}' 2>/dev/null` : ua( %conf );
    print "$content\n" if $content && $verbose;
    ( ( defined $content ) && ( ! defined $conf{check} || $conf{check} eq '' || $content =~ /$conf{check}/ ) )
      ? 1 : 0;
}

sub ua
{
    my %conf = @_;

    my %opt = $conf{http} =~ /^https/ ? ( ssl_opts => { verify_hostname => 0 } ) :();

    my $ua = LWP::UserAgent->new( %opt );
    $ua->agent('Mozilla/9 [en] (Centos; Linux)');
    $ua->timeout( 10 );
    $ua->default_header ( 'Cache-control' => 'no-cache', 'Pragma' => 'no-cache', Host => $conf{Host} );
    my $res = $conf{from} 
        ? $ua->post( $conf{http}, $conf{from} ) : $ua->get( $conf{http} );
    $res->is_success ? $res->content : undef;
}

sub ioso
{
    my ( $addr, $proto ) = @_;
    return IO::Socket::INET->new(
         PeerAddr => $addr, Blocking => 0,
         Timeout => 10, Type => SOCK_STREAM,
         $proto ? ( Proto => $proto ) : ()
    );
}

sub _dig
{
    my ( $domain, $dns, $timeout, @ser ) = splice @_, 0, 3;
    for( 1..2 )
    {
        last if @ser = map{ inet_ntoa( $_ ) }
            Net::DNS::Dig->new( PeerAddr => $dns, Timeout => $timeout || 5 )
                ->for( $domain )->rdata();
    }
    return @ser;
}

