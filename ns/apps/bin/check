#!/home/s/ops/perl/bin/perl
use strict;
use warnings;
use NS::Util::OptConf;
use Sys::Hostname;
use YAML::XS;
use Data::Dumper;
use Encode;
use LWP::UserAgent;
use IO::Socket;

use Net::DNS::Dig;
use NetAddr::IP::Util qw(inet_ntoa);

$| ++;
#use constant CONF => '/ns/apps/conf/janus.check';

#my ( %guide, %seco ); 
#BEGIN {
#   %guide = NS::Util::OptConf->load()->dump( 'guide' ); 
#   %seco  = NS::Util::OptConf->load()->dump( 'seco' ); 
#};
#use lib $guide{lib};
#use Guide2;
#use lib $seco{lib};
#use SECO::Conf;
#use SECO::Conf::Auto;

my ( $option, %apps );
BEGIN { %apps = NS::Util::OptConf->load()->dump('apps'); }
#print Dumper $config;
my %o = NS::Util::OptConf->load()->get( qw( range=s apps=s check=s verbose ) )->dump();

my $arg; map{ $arg .= $o{$_} ? " --$_ $o{$_} " : '' } qw( check apps );

our $verbose = $o{verbose};

my $ver = $o{verbose} ? " --verbose  ":'';
exec "$ENV{'PWD'}/../../tools/mcmd -r '$o{range}' \"$0 $ver $arg {}\"" if $o{range};
my ( $check, @a ) = $ARGV[0] || hostname;
unless( $o{check} )
{
     my $node = eval { YAML::XS::LoadFile( "$apps{data}/node" ) } || die 'cannot find the node file';
     while ( my ( $host, $hermes ) = each %$node )
     {
         
         my $config = eval { YAML::XS::LoadFile( "$apps{conf}/check" ) } || die 'cannot find the config file';
         print Dumper $host;
         print Dumper keys $hermes;
     }
#    $apps = YAML::XS::Load $apps;
#    die "undef in guide" unless $apps && ref $apps eq 'HASH';
#    if( $o{apps} )
#    {
#        push @a, $o{apps} eq 'all'
#            ? map{ $apps->{$_} }sort keys %$apps
#            : $o{apps} =~ ','
#                ? map{ $apps->{$_} }split /,/, $o{apps}
#                : $apps->{$o{apps}};
#    }
#    elsif( keys %$apps != 1 )
#    {
#        printf "please select: | %s |\n", join ' | ', sort keys $apps, 'all';
#        YAML::XS::DumpFile \*STDOUT, $apps;
#        exit 1;
#    }
#    else{ push @a, values %$apps; }
#}
#else { push @a, +{ %o }; }
#
#my $config = YAML::XS::LoadFile CONF;
#map
#{
#    die "use a undef apps' name" unless my $group = $_->{check} || $_->{service};
#    
#    my $conf = $config->{$group} ? $config->{$group} : $config->{'*'};
#    
#    die 'conf undef for check.' unless $conf;
#    
#    for my $c ( ref $conf eq 'ARRAY' ? @$conf : ( $conf ) )
#    {
#        die "invalid conf: no HASH" if ref $c ne 'HASH';
#        my @check;
#        if( $c->{seco} )
#        {
#            my $seco = SECO::Conf::Auto->new( $seco{conf} );
#            my %sname = $seco->search( $check );
#            die "host $check no in seco." unless my @sname = @{$sname{$check}};
#            my $file = File::Spec->join( $seco{conf}, "$sname[0]\@$sname[1]" );
#            my %vips = SECO::Conf->load( $file )->dump( hash => $sname[2] );
#        
#            @check = @{$vips{$check}};
#        }
#        else { push @check, $check; }
#    
#        map{ apps_http( $_, %$c ) }@check if $c->{http};
#        map{ apps_port( $_, %$c ) }@check if $c->{port};
#        map{ apps_port( $_, %$c ) }@check if $c->{tcp};
#        map{ apps_port( $_, %$c ) }@check if $c->{udp};
#        map{ apps_code( $_, %$c ) }@check if $c->{code};
#
#        map{ apps_dns(  $_, %$c ) }@check if $c->{domain};
#        map{ apps_domain(  $_, %$c ) }@check if $c->{dns};
#    }
}@a;
#
#sub apps_dns
#{
#    my ( $host, %conf ) = @_;
#
#    my @to = _dig( $conf{domain} , $host, $conf{timeout}  );
#    printf "to: %s\n", join ',', @to if $verbose;
#
#    @to ? print "$host <> to $conf{domain} :OK\n" : die "$host <> to $conf{domain} :FAIL\n"; 
#}
#
#sub apps_domain
#{
#    my ( $host, %conf ) = @_;
#
#    my @to = _dig( $host, $conf{dns} , $conf{timeout}  );
#    printf "to: %s\n", join ',', @to if $verbose;
#
#    @to ? print "$host <> from $conf{dns} :OK\n" : die "$host <> from $conf{dns} :FAIL\n"; 
#}
#
#sub apps_code
#{
#    my ( $host, %conf ) = @_;
#    my $code = $conf{code};
#    die "$host <> $code :FAIL [no code]\n" unless -x $code;
#    system( "$code $host" ) ? die "$host <> $code :FAIL\n" : print "$host <> $code :OK\n"; 
#}
#
#sub apps_port
#{
#    my ( $host, %conf ) = @_;
#    my ( $port, $t );
#    map{ if( $conf{$_} ){ $t = $_; $port = $conf{$_}; } }qw( tcp udp port );
#    my $info = sprintf "$host <>$t $port";
#
#    ioso( "$host:$port", $t eq 'port' ? '' : $t )
#      ? print "$info :OK\n" : die "$info :FAIL\n";
#}
#
#sub apps_http
#{
#    my ( $host, %conf ) = @_;
#    $conf{http} =~ s/{}/$host/g;
#    Encode::_utf8_off( $conf{check} ) if defined $conf{check};
#    my $info = $conf{check} || '';
#    check_http_conten( %conf )
#      ? print "$conf{http} <> $info :OK\n" : die "$conf{http} <> $info :FAIL\n";
#}
#
#sub check_http_conten
#{
#    my %conf = @_;
#    my $content = $conf{Data} ? `curl $conf{http} -d '$conf{Data}' 2>/dev/null` : ua( %conf );
#    print "$content\n" if $content && $verbose;
#    ( ( defined $content ) && ( ! defined $conf{check} || $conf{check} eq '' || $content =~ /$conf{check}/ ) )
#      ? 1 : 0;
#}
#
#sub ua
#{
#    my %conf = @_;
#
#    my %opt = $conf{http} =~ /^https/ ? ( ssl_opts => { verify_hostname => 0 } ) :();
#
#    my $ua = LWP::UserAgent->new( %opt );
#    $ua->agent('Mozilla/9 [en] (Centos; Linux)');
#    $ua->timeout( 10 );
#    $ua->default_header ( 'Cache-control' => 'no-cache', 'Pragma' => 'no-cache', Host => $conf{Host} );
#    my $res = $conf{from} 
#        ? $ua->post( $conf{http}, $conf{from} ) : $ua->get( $conf{http} );
#    $res->is_success ? $res->content : undef;
#}
#
#sub ioso
#{
#    my ( $addr, $proto ) = @_;
#    return IO::Socket::INET->new(
#         PeerAddr => $addr, Blocking => 0,
#         Timeout => 10, Type => SOCK_STREAM,
#         $proto ? ( Proto => $proto ) : ()
#    );
#}
#
#sub _dig
#{
#    my ( $domain, $dns, $timeout, @ser ) = splice @_, 0, 3;
#    for( 1..2 )
#    {
#        last if @ser = map{ inet_ntoa( $_ ) }
#            Net::DNS::Dig->new( PeerAddr => $dns, Timeout => $timeout || 5 )
#                ->for( $domain )->rdata();
#    }
#    return @ser;
#}
#
